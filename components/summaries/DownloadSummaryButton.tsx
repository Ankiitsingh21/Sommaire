"use client";
import React, { useState } from "react";
import { Button } from "../ui/button";
import { Download, Loader2 } from "lucide-react";
import { jsPDF } from "jspdf";

export default function DownloadSummaryButton({
  fileName,
  originalFileUrl,
  title,
  summaryText,
  createdAt,
}: {
  fileName: string;
  originalFileUrl: string;
  title: string;
  summaryText: string;
  createdAt: string;
}) {
  const [isDownloading, setIsDownloading] = useState(false);

  const cleanAndFormatText = (text: string) => {
    // Ensure we have a string to work with
    if (typeof text !== "string") {
      return "";
    }

    return (
      text
        // Remove markdown headers
        .replace(/^#{1,6}\s/gm, "")
        // Clean up garbled emoji/unicode characters (common pattern: Ø=Ü, Ø<ß, etc.)
        .replace(/Ø[=<>][^\s]{1,3}/g, "")
        // Remove other garbled characters and symbols
        .replace(/[^\x20-\x7E\u00A0-\u024F\u2010-\u204F]/g, "")
        // Remove bullet points and clean up, standardize to simple bullet
        .replace(/^[•·*-]\s*/gm, "• ")
        // Clean up extra whitespace and normalize spacing
        .replace(/\s+/g, " ")
        .replace(/\n\s*\n/g, "\n\n")
        // Remove any remaining single characters that might be artifacts
        .replace(/^\s*[^\w\s•]\s*$/gm, "")
        .trim()
    );
  };

  const addHeader = (doc: jsPDF) => {
    // Header background
    doc.setFillColor(245, 245, 245);
    doc.rect(0, 0, 210, 25, "F");

    // Title
    doc.setFont("helvetica", "bold");
    doc.setFontSize(16);
    doc.setTextColor(51, 51, 51);
    doc.text(title, 15, 15);

    // Subtitle
    doc.setFont("helvetica", "normal");
    doc.setFontSize(10);
    doc.setTextColor(102, 102, 102);
    doc.text("Document Summary", 15, 21);
  };

  const addMetadata = (doc: jsPDF, startY: number) => {
    const metadata = [
      { label: "Original File:", value: fileName },
      { label: "Generated:", value: new Date(createdAt).toLocaleString() },
      { label: "Generated by:", value: "Sommaire" },
    ];

    doc.setFont("helvetica", "normal");
    doc.setFontSize(10);

    let currentY = startY;

    metadata.forEach((item) => {
      doc.setTextColor(102, 102, 102);
      doc.text(item.label, 15, currentY);
      doc.setTextColor(51, 51, 51);
      doc.text(item.value, 55, currentY);
      currentY += 6;
    });

    // Add separator line
    doc.setDrawColor(200, 200, 200);
    doc.line(15, currentY + 2, 195, currentY + 2);

    return currentY + 8;
  };

  const parseStructuredContent = (content: string) => {
    const sections: Array<{ title: string; content: string[] }> = [];
    const lines = content
      .split("\n")
      .filter((line) => typeof line === "string" && line.trim());

    let currentSection = { title: "", content: [] as string[] };

    for (let i = 0; i < lines.length; i++) {
      const rawLine = lines[i];
      if (typeof rawLine !== "string") continue;

      const line = rawLine.trim();

      // Skip empty lines or artifacts
      if (!line || line.length < 3) continue;

      // Check if this looks like a section header (capitalized, no bullet)
      const isHeader =
        !line.startsWith("•") &&
        line.length < 50 &&
        /^[A-Z][a-zA-Z\s]+$/.test(line.replace(/[^\w\s]/g, "").trim()) &&
        !line.includes(":") &&
        line !== line.toLowerCase();

      if (isHeader && currentSection.content.length > 0) {
        // Save previous section
        sections.push({ ...currentSection });
        currentSection = { title: line, content: [] };
      } else if (isHeader && currentSection.content.length === 0) {
        currentSection.title = line;
      } else {
        // This is content
        currentSection.content.push(line);
      }
    }

    // Add the last section
    if (currentSection.title || currentSection.content.length > 0) {
      sections.push(currentSection);
    }

    return sections;
  };

  const addContent = (doc: jsPDF, content: string, startY: number) => {
    const cleanContent = cleanAndFormatText(content);
    const sections = parseStructuredContent(cleanContent);

    let currentY = startY;
    const pageHeight = doc.internal.pageSize.height;
    const bottomMargin = 25;
    const lineHeight = 6;
    const sectionSpacing = 10;

    sections.forEach((section, sectionIndex) => {
      // Add section title if it exists
      if (section.title) {
        // Check if we need a new page for the section title
        if (currentY > pageHeight - bottomMargin - 20) {
          doc.addPage();
          currentY = 20;
        }

        doc.setFont("helvetica", "bold");
        doc.setFontSize(13);
        doc.setTextColor(51, 51, 51);
        doc.text(section.title, 15, currentY);
        currentY += lineHeight + 3;
      }

      // Add section content
      doc.setFont("helvetica", "normal");
      doc.setFontSize(10);
      doc.setTextColor(68, 68, 68);

      section.content.forEach((rawLine) => {
        if (typeof rawLine !== "string") return;

        const line = rawLine.trim();
        if (!line) return;

        // Handle bullet points
        if (line.startsWith("• ")) {
          const bulletText = line.substring(2);
          if (typeof bulletText !== "string" || !bulletText.trim()) return;

          const wrappedBullet = doc.splitTextToSize(
            `• ${bulletText.trim()}`,
            175,
          );

          wrappedBullet.forEach((wrappedLine: string, index: number) => {
            if (typeof wrappedLine !== "string") return;

            if (currentY > pageHeight - bottomMargin) {
              doc.addPage();
              currentY = 25;
            }

            if (index === 0) {
              doc.text(wrappedLine, 15, currentY);
            } else {
              doc.text(wrappedLine.trim(), 20, currentY);
            }
            currentY += lineHeight;
          });
          currentY += 1; // Small spacing after bullet points
        } else {
          // Regular text
          const cleanLine = line.trim();
          if (!cleanLine || typeof cleanLine !== "string") return;

          const wrappedText = doc.splitTextToSize(cleanLine, 180);
          wrappedText.forEach((wrappedLine: string) => {
            if (typeof wrappedLine !== "string") return;

            if (currentY > pageHeight - bottomMargin) {
              doc.addPage();
              currentY = 25;
            }
            doc.text(wrappedLine.trim(), 15, currentY);
            currentY += lineHeight;
          });
          currentY += 2; // Extra spacing after paragraphs
        }
      });

      // Add spacing between sections
      if (sectionIndex < sections.length - 1) {
        currentY += sectionSpacing;
      }
    });
  };

  const addFooter = (doc: jsPDF) => {
    const pageCount = doc.getNumberOfPages();

    for (let i = 1; i <= pageCount; i++) {
      doc.setPage(i);

      // Footer line
      doc.setDrawColor(200, 200, 200);
      doc.line(15, 285, 195, 285);

      // Page number
      doc.setFont("helvetica", "normal");
      doc.setFontSize(9);
      doc.setTextColor(102, 102, 102);
      doc.text(`Page ${i} of ${pageCount}`, 15, 292);

      // Generated by text (right aligned)
      const timestamp = new Date().toLocaleString();
      doc.text(`Generated on ${timestamp}`, 195, 292, { align: "right" });
    }
  };

  const generateSafeFileName = (title: string) => {
    const cleanTitle = title
      .replace(/[^a-z0-9\s-_]/gi, "")
      .replace(/\s+/g, "_")
      .substring(0, 50);

    const timestamp = new Date().toISOString().slice(0, 10);
    return `Summary_${cleanTitle}_${timestamp}.pdf`;
  };

  const handleDownload = async () => {
    if (!summaryText?.trim()) {
      alert("No summary content available to download.");
      return;
    }

    setIsDownloading(true);

    try {
      const doc = new jsPDF();

      // Add header
      addHeader(doc);

      // Add metadata
      const contentStartY = addMetadata(doc, 35);

      // Add main content
      addContent(doc, summaryText, contentStartY);

      // Add footer
      addFooter(doc);

      // Generate safe filename
      const safeFileName = generateSafeFileName(title);

      // Save the PDF
      doc.save(safeFileName);
    } catch (error) {
      console.error("Error generating PDF:", error);
      alert("Failed to generate PDF. Please try again.");
    } finally {
      setIsDownloading(false);
    }
  };

  return (
    <Button
      size="sm"
      className="h-8 px-3 bg-rose-100 text-rose-600 hover:text-rose-700 hover:bg-rose-50 disabled:opacity-60 disabled:cursor-not-allowed transition-all duration-200"
      onClick={handleDownload}
      disabled={isDownloading || !summaryText?.trim()}
    >
      {isDownloading ? (
        <Loader2 className="h-4 w-4 mr-1 animate-spin" />
      ) : (
        <Download className="h-4 w-4 mr-1" />
      )}
      {isDownloading ? "Generating..." : "Download Summary"}
    </Button>
  );
}
